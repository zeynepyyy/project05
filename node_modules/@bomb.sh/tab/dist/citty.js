import{c as e,d as t,l as n,s as r,u as i}from"./t-Chww2rEs.js";import{t as a}from"./shared-BE1U9MBi.js";import{defineCommand as o}from"citty";async function s(e){let t=[],n=[];for(let[r,i]of Object.entries(e))if(i.type===`positional`){let e=i;n.push({name:r,description:e.description,isOptional:!e.required,isVariadic:r.startsWith(`[...`)||r.startsWith(`<...`)})}else{let e={name:`--${r}`,description:i.description||``,isRequired:i.required};`alias`in i&&i.alias&&(Array.isArray(i.alias)?i.alias:[i.alias]).forEach(n=>{t.push({...e,name:`-${n}`})}),t.push(e)}return{options:t,args:n}}async function c(e,t=``){let n=await Promise.resolve(e.meta),r=await Promise.resolve(e.subCommands);if(!n||!n.name)throw Error(`Command meta or name is missing`);let i={name:t?`${t} ${n.name}`:n.name,description:n.description||``};if(e.args){let{options:t,args:n}=await s(await Promise.resolve(e.args));t.length>0&&(i.options=t),n.length>0&&(i.args=n)}return r&&(i.subcommands=await Promise.all(Object.entries(r).map(async([e,t])=>c(await Promise.resolve(t),i.name)))),i}async function l(e){let t=await c(e);return JSON.stringify(t,null,2)}function u(e){return e.includes(` `)?`'${e}'`:e}const d=process.execPath,f=process.argv.slice(1),p=u(d),m=f.map(u),h=`${p} ${process.execArgv.map(u).join(` `)} ${m[0]}`;function g(e){return e.args&&Object.values(e.args).some(e=>e.type===`positional`)}async function _(e,t,n){for(let[i,a]of Object.entries(e)){let e=await y(a),o=await y(e.meta),s=await y(e.subCommands),c=n?.[i];if(!o||typeof o?.description!=`string`)throw Error(`Invalid meta or missing description.`);let l=g(e),u=t?`${t} ${i}`:i,d=r.command(u,o.description);if(l&&e.args)for(let[t,n]of Object.entries(e.args)){let e=n;if(e.type===`positional`){let n=e.required===!1,r=c?.args?.[t];r?d.argument(t,r,n):d.argument(t,void 0,n)}}if(s&&await _(s,u,c?.subCommands),e.args)for(let[t,n]of Object.entries(e.args)){let e=n,r=typeof e==`object`&&`alias`in e?Array.isArray(e.alias)?e.alias[0]:e.alias:void 0,i=c?.options?.[t];i?r?d.option(t,e.description??``,i,r):d.option(t,e.description??``,i):r?d.option(t,e.description??``,r):d.option(t,e.description??``)}}}async function v(s,c){let u=await y(s.meta);if(!u)throw Error(`Invalid meta.`);let d=u.name;if(!d)throw Error(`Invalid meta or missing name.`);let f=await y(s.subCommands);if(g(s)&&s.args)for(let[e,t]of Object.entries(s.args)){let n=t;if(n.type===`positional`){let t=n.required===!1,i=c?.args?.[e];i?r.argument(e,i,t):r.argument(e,void 0,t)}}if(f&&await _(f,void 0,c?.subCommands),s.args)for(let[e,t]of Object.entries(s.args)){let n=t,i=typeof n==`object`&&`alias`in n?Array.isArray(n.alias)?n.alias[0]:n.alias:void 0,a=c?.options?.[e];a?i?r.option(e,n.description??``,a,i):r.option(e,n.description??``,a):i?r.option(e,n.description??``,i):r.option(e,n.description??``)}let p=o({meta:{name:`complete`,description:`Generate shell completion scripts`},args:{shell:{type:`positional`,description:`Shell type (zsh, bash, fish, powershell, fig)`,required:!1}},async run(o){let c=o.rawArgs[0];switch(c===`--`&&(c=void 0),c){case`zsh`:{let e=t(d,h);console.log(e);break}case`bash`:{let e=i(d,h);console.log(e);break}case`fish`:{let e=n(d,h);console.log(e);break}case`powershell`:{let t=e(d,h);console.log(t);break}case`fig`:{let e=await l(s);console.log(e);break}default:{a(d);let e=o.rawArgs.slice(o.rawArgs.indexOf(`--`)+1);return r.parse(e)}}}});return f?f.complete=p:s.subCommands={complete:p},r}async function y(e){return e instanceof Function?await e():await e}export{v as default};